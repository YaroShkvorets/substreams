import { log } from "@graphprotocol/graph-ts";
import { Protobuf } from "as-proto/assembly";
import { JSON } from "assemblyscript-json";
{{- range $entityName, $entity := $.GetEntities }}
import { {{ $entityName}} as {{$entity.NameAsProto}}} from "./pb/{{ $entity.ProtobufPath }}";
import { {{ $entity.NameAsEntity }} } from "../generated/schema";
{{- end -}}

export function handleTriggers(bytes: Uint8Array): void {
  {{ $mainEntity := $.GetMainEntity }}
  const $mainEntity.NameAsProto = Protobuf.decode<{{ $mainEntity.NameAsProto}}>(
    bytes,
    {{ $mainEntity.NameAsProto}}.decode
  );

  let mainId = crypto.keccak256(Bytes.fromUint8Array(bytes)).toHexString();

  {{ template "entityFromProto" (arr $mainEntity "mainId") }}
}

function ID(parentID: string, messageName: string): string {
  return parentID + "-" + messageName;
}

function IDWithIndex(parentID: string, messageName: string, index: number): string {
  return parentID + "-" + messageName + "-" + index.toString();
}


{{define "entityFromProto"}}
  {{ $parentEntity := index . 0 }}
  {{ $parentId := index . 1 }}
  let $parentEntity.NameAsEntity = new {{ $parentEntity.NameAsEntity }}(parentId);

     - for nested entities
             let {{ $parentId }} = ID(parentId + "nestedEntityName")
             let nestedEntity = new NestedEntity(nestedEntityID)
             {{ template "entityFromProto" (arr .nestedEntity nestedEntityID) }}

    //Handle classic fields
    -Create entityJsonValue JSON object
    -set all classic fields
    -$parentEntity.NameAsEntity.jsonValue = entityJsonValue.ToString()
    -save

   $parentEntity.NameAsEntity.save()
{{end}}

